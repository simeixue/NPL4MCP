[
  {
    "name": "create_chronulus_session",
    "description": "\nA tool that creates a new Chronulus Session and returns a session_id\n\nWhen to use this tool:\n- Use this tool when a user has requested a forecast or prediction for a new use case\n- Before calling this tool make sure you have enough information to write a well-defined situation and task. You might\nneed to ask clarifying questions in order to get this from the user.\n- The same session_id can be reused as long as the situation and task remain the same\n- If user wants to forecast a different use case, create a new session and then use that\n\nHow to use this tool:\n- To create a session, you need to provide a situation and task that describe the forecasting use case \n- If the user has not provided enough detail for you to decompose the use case into a \n    situation (broad or background context) and task (specific requirements for the forecast), \n    ask them to elaborate since more detail will result in a better / more accurate forecast.\n- Once created, this will generate a unique session_id that can be used to when calling other tools about this use case.\n",
    "input_schema": {
      "properties": {
        "name": {
          "description": "A short descriptive name for the use case defined in the session.",
          "title": "Name",
          "type": "string"
        },
        "situation": {
          "description": "The broader context for the use case",
          "title": "Situation",
          "type": "string"
        },
        "task": {
          "description": "Specific details on the forecasting or prediction task.",
          "title": "Task",
          "type": "string"
        }
      },
      "required": [
        "name",
        "situation",
        "task"
      ],
      "title": "create_chronulus_sessionArguments",
      "type": "object"
    },
    "annotations": {},
    "implementation": "# file: /Users/xue/workspace/mcp_project/mcp_server_pyrepos/chronulus-mcp/src/chronulus_mcp/session.py\n# module: src.chronulus_mcp.session\n# qname: src.chronulus_mcp.session.create_chronulus_session\n# lines: 8-42\nasync def create_chronulus_session(\n        name: Annotated[str, Field(description=\"A short descriptive name for the use case defined in the session.\")],\n        situation: Annotated[str, Field(description=\"The broader context for the use case\")],\n        task: Annotated[str, Field(description=\"Specific details on the forecasting or prediction task.\")],\n        ctx: Context\n) -> str:\n    \"\"\"Creates a new Chronulus Session\n\n    A Chronulus Session allows you to use Chronulus Agents. To create a session, you need to provide a situation\n    and task. Once created, this will generate a unique session id that can be used to when calling the agents.\n\n    Args:\n        name (str): A short descriptive name for the use case defined in the session.\n        situation (str): The broader context for the use case.\n        task (str): The specific prediction task.\n\n\n    Returns:\n        str: The session ID.\n    \"\"\"\n\n    try:\n        chronulus_session = Session(\n            name=name,\n            situation=situation,\n            task=task,\n            verbose=False,\n        )\n\n    except Exception as e:\n        error_message = f\"Failed to create chronulus session with the following error: \\n\\n{e}\"\n        _ = await ctx.error(message=error_message)\n        return error_message\n\n    return chronulus_session.session_id\n"
  },
  {
    "name": "create_forecasting_agent_and_get_forecast",
    "description": "\nThis tool creates a NormalizedForecaster agent with your session and input data model and then provides a forecast input \ndata to the agent and returns the prediction data and text explanation from the agent.\n\nWhen to use this tool:\n- Use this tool to request a forecast from Chronulus\n- This tool is specifically made to forecast values between 0 and 1 and does not require historical data\n- The prediction can be thought of as seasonal weights, probabilities, or shares of something as in the decimal representation of a percent\n\nHow to use this tool:\n- First, make sure you have a session_id for the forecasting or prediction use case.\n- Next, think about the features / characteristics most suitable for producing the requested forecast and then \ncreate an input_data_model that corresponds to the input_data you will provide for the thing being forecasted.\n- Remember to pass all relevant information to Chronulus including text and images provided by the user. \n- If a user gives you files about a thing you are forecasting or predicting, you should pass these as inputs to the \nagent using one of the following types: \n    - ImageFromFile\n    - List[ImageFromFile]\n    - TextFromFile\n    - List[TextFromFile]\n    - PdfFromFile\n    - List[PdfFromFile]\n- If you have a large amount of text (over 500 words) to pass to the agent, you should use the Text or List[Text] field types\n- Finally, add information about the forecasting horizon and time scale requested by the user\n- Assume the dates and datetimes in the prediction results are already converted to the appropriate local timezone if location is a factor in the use case. So do not try to convert from UTC to local time when plotting.\n- When plotting the predictions, use a Rechart time series with the appropriate axes labeled and with the prediction explanation displayed as a caption below the plot\n",
    "input_schema": {
      "$defs": {
        "InputField": {
          "properties": {
            "name": {
              "description": "Field name. Should be a valid python variable name.",
              "title": "Name",
              "type": "string"
            },
            "description": {
              "description": "A description of the value you will pass in the field.",
              "title": "Description",
              "type": "string"
            },
            "type": {
              "default": "str",
              "description": "The type of the field. \n        ImageFromFile takes a single named-argument, 'file_path' as input which should be absolute path to the image to be included. So you should provide this input as json, eg. {'file_path': '/path/to/image'}.\n        ",
              "enum": [
                "str",
                "Text",
                "List[Text]",
                "TextFromFile",
                "List[TextFromFile]",
                "PdfFromFile",
                "List[PdfFromFile]",
                "ImageFromFile",
                "List[ImageFromFile]"
              ],
              "title": "Type",
              "type": "string"
            }
          },
          "required": [
            "name",
            "description"
          ],
          "title": "InputField",
          "type": "object"
        }
      },
      "properties": {
        "session_id": {
          "description": "The session_id for the forecasting or prediction use case",
          "title": "Session Id",
          "type": "string"
        },
        "input_data_model": {
          "description": "Metadata on the fields you will include in the input_data.",
          "items": {
            "$ref": "#/$defs/InputField"
          },
          "title": "Input Data Model",
          "type": "array"
        },
        "input_data": {
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "items": {
                  "additionalProperties": true,
                  "type": "object"
                },
                "type": "array"
              }
            ]
          },
          "description": "The forecast inputs that you will pass to the chronulus agent to make the prediction. The keys of the dict should correspond to the InputField name you provided in input_fields.",
          "title": "Input Data",
          "type": "object"
        },
        "forecast_start_dt_str": {
          "description": "The datetime str in '%Y-%m-%d %H:%M:%S' format of the first value in the forecast horizon.",
          "title": "Forecast Start Dt Str",
          "type": "string"
        },
        "time_scale": {
          "default": "days",
          "description": "The times scale of the forecast horizon. Valid time scales are 'hours', 'days', and 'weeks'.",
          "title": "Time Scale",
          "type": "string"
        },
        "horizon_len": {
          "default": 60,
          "description": "The integer length of the forecast horizon. Eg., 60 if a 60 day forecast was requested.",
          "title": "Horizon Len",
          "type": "integer"
        }
      },
      "required": [
        "session_id",
        "input_data_model",
        "input_data",
        "forecast_start_dt_str"
      ],
      "title": "create_forecasting_agent_and_get_forecastArguments",
      "type": "object"
    },
    "annotations": {},
    "implementation": "# file: /Users/xue/workspace/mcp_project/mcp_server_pyrepos/chronulus-mcp/src/chronulus_mcp/agent/forecaster.py\n# module: src.chronulus_mcp.agent.forecaster\n# qname: src.chronulus_mcp.agent.forecaster.create_forecasting_agent_and_get_forecast\n# lines: 16-103\nasync def create_forecasting_agent_and_get_forecast(\n        session_id: Annotated[str, Field(description=\"The session_id for the forecasting or prediction use case\")],\n        input_data_model: Annotated[List[InputField], Field(\n            description=\"\"\"Metadata on the fields you will include in the input_data.\"\"\"\n        )],\n        input_data: Annotated[Dict[str, Union[str, dict, List[dict]]], Field(description=\"The forecast inputs that you will pass to the chronulus agent to make the prediction. The keys of the dict should correspond to the InputField name you provided in input_fields.\")],\n        forecast_start_dt_str: Annotated[str, Field(description=\"The datetime str in '%Y-%m-%d %H:%M:%S' format of the first value in the forecast horizon.\")],\n        ctx: Context,\n        time_scale: Annotated[str, Field(description=\"The times scale of the forecast horizon. Valid time scales are 'hours', 'days', and 'weeks'.\", default=\"days\")],\n        horizon_len: Annotated[int, Field(description=\"The integer length of the forecast horizon. Eg., 60 if a 60 day forecast was requested.\", default=60)],\n) -> Union[str, Dict[str, Union[dict, str]]]:\n    \"\"\"Queues and retrieves a forecast from Chronulus with a predefined session_id\n\n    This tool creates a NormalizedForecaster agent and then provides a forecast input to the agent and returns the prediction data and\n    text explanation from the agent.\n\n    Args:\n        session_id (str): The session_id for the forecasting or prediction use case.\n        input_data_model (List[InputField]): Metadata on the fields you will include in the input_data. Eg., for a field named \"brand\", add a description like \"the brand of the product to forecast\"\n        input_data (Dict[str, Union[str, dict, List[dict]]]): The forecast inputs that you will pass to the chronulus agent to make the prediction. The keys of the dict should correspond to the InputField name you provided in input_fields.\n        forecast_start_dt_str (str): The datetime str in '%Y-%m-%d %H:%M:%S' format of the first value in the forecast horizon.\"\n        ctx (Context): Context object providing access to MCP capabilities.\n        time_scale (str): The times scale of the forecast horizon. Valid time scales are 'hours', 'days', and 'weeks'.\n        horizon_len (int): The integer length of the forecast horizon. Eg., 60 if a 60 day forecast was requested.\n\n    Returns:\n        Union[str, Dict[str, Union[dict, str]]]: a dictionary with prediction data, a text explanation of the predictions, estimator_id, and the prediction id.\n    \"\"\"\n\n\n    try:\n        chronulus_session = Session.load_from_saved_session(session_id=session_id, verbose=False)\n    except Exception as e:\n        error_message = f\"Failed to retrieve session with session_id: {session_id}\\n\\n{e}\"\n        _ = await ctx.error( message=error_message)\n        return error_message\n\n    try:\n        InputItem = generate_model_from_fields(\"InputItem\", input_data_model)\n    except Exception as e:\n        error_message = f\"Failed to create InputItem model with input data model: {json.dumps(input_data_model, indent=2)}\\n\\n{e}\"\n        _ = await ctx.error(message=error_message)\n        return error_message\n\n    try:\n        item = InputItem(**input_data)\n    except Exception as e:\n        error_message = f\"Failed to validate the input_data with the generated InputItem model. \\n\\n{e}\"\n        _ = await ctx.error(message=error_message)\n        return error_message\n\n    try:\n        nf_agent = NormalizedForecaster(\n            session=chronulus_session,\n            input_type=InputItem,\n            verbose=False,\n        )\n    except Exception as e:\n        return f\"\"\"Error at nf_agent: {str(e)}\n        \ninput_fields = {input_data_model}\n\ninput_data = {json.dumps(input_data, indent=2)}\n\ninput_type = {str(type(InputItem))}\n\"\"\"\n\n    try:\n        forecast_start_dt = datetime.fromisoformat(forecast_start_dt_str)\n        horizon_params = {\n            'start_dt': forecast_start_dt,\n            time_scale: horizon_len\n        }\n        req = nf_agent.queue(item, **horizon_params)\n    except Exception as e:\n        return f\"\"\"Error at nf_agent: {str(e)}\"\"\"\n\n    try:\n        predictions = nf_agent.get_predictions(req.request_id)\n        prediction = predictions[0]\n        return {\n            \"agent_id\": nf_agent.estimator_id,\n            \"prediction_id\": prediction.id,\n            'data': prediction.to_json(orient='rows'),\n            'explanation': prediction.text}\n\n    except Exception as e:\n        return f\"\"\"Error on prediction: {str(e)}\"\"\"\n\n#callee：\n# file: /Users/xue/workspace/mcp_project/mcp_server_pyrepos/chronulus-mcp/src/chronulus_mcp/agent/_types.py\n# module: src.chronulus_mcp.agent._types\n# qname: src.chronulus_mcp.agent._types.generate_model_from_fields\n# lines: 26-65\ndef generate_model_from_fields(model_name: str, fields: List[InputField]) -> Type[BaseModel]:\n    \"\"\"\n    Generate a new Pydantic BaseModel from a list of InputField objects.\n\n    Args:\n        model_name: The name for the generated model class\n        fields: List of InputField objects defining the model's fields\n\n    Returns:\n        A new Pydantic BaseModel class with the specified fields\n    \"\"\"\n    literal_type_mapping = {\n        'str': str,\n        'ImageFromFile': ImageFromFile,\n        'List[ImageFromFile]': List[ImageFromFile],\n        'TextFromFile': TextFromFile,\n        'List[TextFromFile]': List[TextFromFile],\n        'PdfFromFile': PdfFromFile,\n        'List[PdfFromFile]': List[PdfFromFile]\n    }\n\n    field_definitions = {\n        field.name: (\n            Optional[literal_type_mapping.get(field.type, str)],\n            Field(description=field.description)\n        )\n        for field in fields\n    }\n\n    DynamicModel = create_model(\n        model_name,\n        __base__=BaseModel,  # Explicitly set BaseModel as the base class\n        **field_definitions\n    )\n\n    DynamicModel.__annotations__ = {\n        field.name: str for field in fields\n    }\n\n    return DynamicModel\n"
  },
  {
    "name": "reuse_forecasting_agent_and_get_forecast",
    "description": "\nThis tool creates a NormalizedForecaster agent with your session and input data model and then provides a forecast input \ndata to the agent and returns the prediction data and text explanation from the agent.\n\nWhen to use this tool:\n- Use this tool to request a forecast from Chronulus\n- This tool is specifically made to forecast values between 0 and 1 and does not require historical data\n- The prediction can be thought of as seasonal weights, probabilities, or shares of something as in the decimal representation of a percent\n\nHow to use this tool:\n- First, make sure you have a session_id for the forecasting or prediction use case.\n- Next, think about the features / characteristics most suitable for producing the requested forecast and then \ncreate an input_data_model that corresponds to the input_data you will provide for the thing being forecasted.\n- Remember to pass all relevant information to Chronulus including text and images provided by the user. \n- If a user gives you files about a thing you are forecasting or predicting, you should pass these as inputs to the \nagent using one of the following types: \n    - ImageFromFile\n    - List[ImageFromFile]\n    - TextFromFile\n    - List[TextFromFile]\n    - PdfFromFile\n    - List[PdfFromFile]\n- If you have a large amount of text (over 500 words) to pass to the agent, you should use the Text or List[Text] field types\n- Finally, add information about the forecasting horizon and time scale requested by the user\n- Assume the dates and datetimes in the prediction results are already converted to the appropriate local timezone if location is a factor in the use case. So do not try to convert from UTC to local time when plotting.\n- When plotting the predictions, use a Rechart time series with the appropriate axes labeled and with the prediction explanation displayed as a caption below the plot\n",
    "input_schema": {
      "properties": {
        "agent_id": {
          "description": "The agent_id for the forecasting or prediction use case and previously defined input_data_model",
          "title": "Agent Id",
          "type": "string"
        },
        "input_data": {
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "items": {
                  "additionalProperties": true,
                  "type": "object"
                },
                "type": "array"
              }
            ]
          },
          "description": "The forecast inputs that you will pass to the chronulus agent to make the prediction. The keys of the dict should correspond to the InputField name you provided in input_fields.",
          "title": "Input Data",
          "type": "object"
        },
        "forecast_start_dt_str": {
          "description": "The datetime str in '%Y-%m-%d %H:%M:%S' format of the first value in the forecast horizon.",
          "title": "Forecast Start Dt Str",
          "type": "string"
        },
        "time_scale": {
          "default": "days",
          "description": "The times scale of the forecast horizon. Valid time scales are 'hours', 'days', and 'weeks'.",
          "title": "Time Scale",
          "type": "string"
        },
        "horizon_len": {
          "default": 60,
          "description": "The integer length of the forecast horizon. Eg., 60 if a 60 day forecast was requested.",
          "title": "Horizon Len",
          "type": "integer"
        }
      },
      "required": [
        "agent_id",
        "input_data",
        "forecast_start_dt_str"
      ],
      "title": "reuse_forecasting_agent_and_get_forecastArguments",
      "type": "object"
    },
    "annotations": {},
    "implementation": "# file: /Users/xue/workspace/mcp_project/mcp_server_pyrepos/chronulus-mcp/src/chronulus_mcp/agent/forecaster.py\n# module: src.chronulus_mcp.agent.forecaster\n# qname: src.chronulus_mcp.agent.forecaster.reuse_forecasting_agent_and_get_forecast\n# lines: 106-158\nasync def reuse_forecasting_agent_and_get_forecast(\n        agent_id: Annotated[str, Field(description=\"The agent_id for the forecasting or prediction use case and previously defined input_data_model\")],\n        input_data: Annotated[Dict[str, Union[str, dict, List[dict]]], Field(\n            description=\"The forecast inputs that you will pass to the chronulus agent to make the prediction. The keys of the dict should correspond to the InputField name you provided in input_fields.\")],\n        forecast_start_dt_str: Annotated[str, Field(\n            description=\"The datetime str in '%Y-%m-%d %H:%M:%S' format of the first value in the forecast horizon.\")],\n        time_scale: Annotated[str, Field(\n            description=\"The times scale of the forecast horizon. Valid time scales are 'hours', 'days', and 'weeks'.\",\n            default=\"days\")],\n        horizon_len: Annotated[int, Field(\n            description=\"The integer length of the forecast horizon. Eg., 60 if a 60 day forecast was requested.\",\n            default=60)],\n) -> Union[str, Dict[str, Union[dict, str]]]:\n    \"\"\"Queues and retrieves a forecast from Chronulus with a previously created agent_id\n\n    This tool provides a forecast input to a previous created Chronulus NormalizedForecaster agent and returns the\n    prediction data and text explanation from the agent.\n\n    Args:\n        agent_id (str): The agent_id for the forecasting or prediction use case and previously defined input_data_model\n        input_data (Dict[str, Union[str, dict, List[dict]]]): The forecast inputs that you will pass to the chronulus agent to make the prediction. The keys of the dict should correspond to the InputField name you provided in input_fields.\n        forecast_start_dt_str (str): The datetime str in '%Y-%m-%d %H:%M:%S' format of the first value in the forecast horizon.\"\n        time_scale (str): The times scale of the forecast horizon. Valid time scales are 'hours', 'days', and 'weeks'.\n        horizon_len (int): The integer length of the forecast horizon. Eg., 60 if a 60 day forecast was requested.\n\n    Returns:\n        Union[str, Dict[str, Union[dict, str]]]: a dictionary with prediction data, a text explanation of the predictions, agent_id, and the prediction id.\n    \"\"\"\n\n    nf_agent = NormalizedForecaster.load_from_saved_estimator(estimator_id=agent_id, verbose=False)\n    item = nf_agent.input_type(**input_data)\n\n    try:\n        forecast_start_dt = datetime.fromisoformat(forecast_start_dt_str)\n        horizon_params = {\n            'start_dt': forecast_start_dt,\n            time_scale: horizon_len\n        }\n        req = nf_agent.queue(item, **horizon_params)\n    except Exception as e:\n        return f\"\"\"Error at nf_agent: {str(e)}\"\"\"\n\n    try:\n        predictions = nf_agent.get_predictions(req.request_id)\n        prediction = predictions[0]\n        return {\n            \"agent_id\": nf_agent.estimator_id,\n            \"prediction_id\": prediction.id,\n            'data': prediction.to_json(orient='rows'),\n            'explanation': prediction.text}\n\n    except Exception as e:\n        return f\"\"\"Error on prediction: {str(e)}\"\"\"\n"
  },
  {
    "name": "rescale_forecast",
    "description": "\nA tool that rescales the prediction data (values between 0 and 1) from the NormalizedForecaster agent to scale required for a use case\n\nWhen to use this tool:\n- Use this tool when there is enough information from the user or use cases to determine a reasonable min and max for the forecast predictions\n- Do not attempt to rescale or denormalize the predictions on your own without using this tool.\n- Also, if the best min and max for the use case is 0 and 1, then no rescaling is needed since that is already the scale of the predictions.\n- If a user requests to convert from probabilities to a unit in levels, be sure to caveat your use of this tool by noting that\n    probabilities do not always scale uniformly to levels. Rescaling can be used as a rough first-pass estimate. But for best results, \n    it would be better to start a new Chronulus forecasting use case predicting in levels from the start.\n    \nHow to use this tool:\n- To use this tool present prediction_id from the normalized prediction and the min and max as floats\n- If the user is also changing units, consider if the units will be inverted and set the inverse scale to True if needed.\n- When plotting the rescaled predictions, use a Rechart time series plot with the appropriate axes labeled and include the chronulus \n    prediction explanation as a caption below the plot. \n- If you would like to add additional notes about the scaled series, put these below the original prediction explanation. \n",
    "input_schema": {
      "properties": {
        "prediction_id": {
          "description": "The prediction_id from a prediction result",
          "title": "Prediction Id",
          "type": "string"
        },
        "y_min": {
          "description": "The expected smallest value for the use case. E.g., for product sales, 0 would be the least possible value for sales.",
          "title": "Y Min",
          "type": "number"
        },
        "y_max": {
          "description": "The expected largest value for the use case. E.g., for product sales, 0 would be the largest possible value would be given by the user or determined from this history of sales for the product in question or a similar product.",
          "title": "Y Max",
          "type": "number"
        },
        "invert_scale": {
          "default": false,
          "description": "Set this flag to true if the scale of the new units will run in the opposite direction from the inputs.",
          "title": "Invert Scale",
          "type": "boolean"
        }
      },
      "required": [
        "prediction_id",
        "y_min",
        "y_max"
      ],
      "title": "rescale_forecastArguments",
      "type": "object"
    },
    "annotations": {},
    "implementation": "# file: /Users/xue/workspace/mcp_project/mcp_server_pyrepos/chronulus-mcp/src/chronulus_mcp/agent/forecaster.py\n# module: src.chronulus_mcp.agent.forecaster\n# qname: src.chronulus_mcp.agent.forecaster.rescale_forecast\n# lines: 161-187\nasync def rescale_forecast(\n    prediction_id: Annotated[str, Field(description=\"The prediction_id from a prediction result\")],\n    y_min: Annotated[float, Field(description=\"The expected smallest value for the use case. E.g., for product sales, 0 would be the least possible value for sales.\")],\n    y_max: Annotated[float, Field(description=\"The expected largest value for the use case. E.g., for product sales, 0 would be the largest possible value would be given by the user or determined from this history of sales for the product in question or a similar product.\")],\n    invert_scale: Annotated[bool, Field(description=\"Set this flag to true if the scale of the new units will run in the opposite direction from the inputs.\", default=False)],\n) -> List[dict]:\n    \"\"\"Rescales prediction data from the NormalizedForecaster agent\n\n    Args:\n        prediction_id (str) : The prediction_id for the prediction you would like to rescale as returned by the forecasting agent\n        y_min (float) : The expected smallest value for the use case. E.g., for product sales, 0 would be the least possible value for sales.\n        y_max (float) : The expected largest value for the use case. E.g., for product sales, 0 would be the largest possible value would be given by the user or determined from this history of sales for the product in question or a similar product.\n        invert_scale (bool): Set this flag to true if the scale of the new units will run in the opposite direction from the inputs.\n\n    Returns:\n        List[dict] : The prediction data rescaled to suit the use case\n    \"\"\"\n\n    normalized_forecast = NormalizedForecaster.get_prediction_static(prediction_id)\n    rescaled_forecast = RescaledForecast.from_forecast(\n        forecast=normalized_forecast,\n        y_min=y_min,\n        y_max=y_max,\n        invert_scale=invert_scale\n    )\n\n    return [DataRow(dt=row.get('date',row.get('datetime')), y_hat=row.get('y_hat')).model_dump() for row in rescaled_forecast.to_json(orient='rows')]\n"
  },
  {
    "name": "save_forecast",
    "description": "\nA tool that saves a Chronulus forecast from NormalizedForecaster to separate CSV and TXT files\n\nWhen to use this tool:\n- Use this tool when you need to save both the forecast data and its explanation to files\n- The forecast data will be saved as a CSV file for data analysis\n- The forecast explanation will be saved as a TXT file for reference\n- Both files will be saved in the same directory specified by output_path\n- This tool can also be used to directly save rescaled predictions without first calling the rescaling tool\n\nHow to use this tool:\n- Provide the prediction_id from a previous forecast\n- Specify the output_path where both files should be saved\n- Provide csv_name for the forecast data file (must end in .csv)\n- Provide txt_name for the explanation file (must end in .txt)\n- Optionally provide y_min and y_max to rescale the predictions (defaults to 0)\n- Set invert_scale to True if the target units run in the opposite direction\n- The tool will provide status updates through the MCP context\n",
    "input_schema": {
      "properties": {
        "prediction_id": {
          "description": "The prediction_id from a prediction result",
          "title": "Prediction Id",
          "type": "string"
        },
        "output_path": {
          "description": "The path where the CSV file should be saved. Should end in .csv",
          "title": "Output Path",
          "type": "string"
        },
        "csv_name": {
          "description": "The path where the CSV file should be saved. Should end in .csv",
          "title": "Csv Name",
          "type": "string"
        },
        "txt_name": {
          "description": "The name of the TXT file to be saved. Should end in .txt",
          "title": "Txt Name",
          "type": "string"
        },
        "y_min": {
          "default": 0.0,
          "description": "The expected smallest value for the use case. E.g., for product sales, 0 would be the least possible value for sales.",
          "title": "Y Min",
          "type": "number"
        },
        "y_max": {
          "default": 1.0,
          "description": "The expected largest value for the use case. E.g., for product sales, 0 would be the largest possible value would be given by the user or determined from this history of sales for the product in question or a similar product.",
          "title": "Y Max",
          "type": "number"
        },
        "invert_scale": {
          "default": false,
          "description": "Set this flag to true if the scale of the new units will run in the opposite direction from the inputs.",
          "title": "Invert Scale",
          "type": "boolean"
        }
      },
      "required": [
        "prediction_id",
        "output_path",
        "csv_name",
        "txt_name"
      ],
      "title": "save_forecastArguments",
      "type": "object"
    },
    "annotations": {},
    "implementation": "# file: /Users/xue/workspace/mcp_project/mcp_server_pyrepos/chronulus-mcp/src/chronulus_mcp/io.py\n# module: src.chronulus_mcp.io\n# qname: src.chronulus_mcp.io.save_forecast\n# lines: 16-61\nasync def save_forecast(\n    prediction_id: Annotated[str, Field(description=\"The prediction_id from a prediction result\")],\n    output_path: Annotated[str, Field(description=\"The path where the CSV file should be saved. Should end in .csv\")],\n    csv_name: Annotated[str, Field(description=\"The path where the CSV file should be saved. Should end in .csv\")],\n    txt_name: Annotated[str, Field(description=\"The name of the TXT file to be saved. Should end in .txt\")],\n    ctx: Context,\n    y_min: Annotated[float, Field(default=0.0, description=\"The expected smallest value for the use case. E.g., for product sales, 0 would be the least possible value for sales.\")],\n    y_max: Annotated[float, Field(default=1.0, description=\"The expected largest value for the use case. E.g., for product sales, 0 would be the largest possible value would be given by the user or determined from this history of sales for the product in question or a similar product.\")],\n    invert_scale: Annotated[bool, Field(default=False, description=\"Set this flag to true if the scale of the new units will run in the opposite direction from the inputs.\")],\n) -> str:\n    \"\"\"Saves the forecast from a NormalizedForecaster agent to CSV and the explanation to TXT\n\n    Args:\n        prediction_id (str): The prediction_id for the prediction you would like to rescale as returned by the forecasting agent\n        output_path (str): The path where the CSV and TXT file should be saved.\n        csv_name (str): The name of the CSV file to be saved. Should end in .csv\n        txt_name (str): The name of the TXT file to be saved. Should end in .txt\n        ctx (Context): Context object providing access to MCP capabilities.\n        y_min (float): The expected smallest value for the use case. E.g., for product sales, 0 would be the least possible value for sales.\n        y_max (float): The expected largest value for the use case. E.g., for product sales, 0 would be the largest possible value would be given by the user or determined from this history of sales for the product in question or a similar product.\n        invert_scale (bool): Set this flag to true if the scale of the new units will run in the opposite direction from the inputs.\n\n\n    Returns:\n        str: A message confirming the file was saved and its location\n    \"\"\"\n    # Get normalized forecast and rescale it\n    _ = await ctx.info(f\"Fetching prediction data for {prediction_id}\")\n    normalized_forecast = NormalizedForecaster.get_prediction_static(prediction_id, verbose=False)\n    rescaled_forecast = RescaledForecast.from_forecast(\n        forecast=normalized_forecast,\n        y_min=y_min,\n        y_max=y_max,\n        invert_scale=invert_scale\n    )\n\n    # Convert to pandas using built-in method\n    df = rescaled_forecast.to_pandas()\n\n    # Save to CSV\n    df.to_csv(os.path.join(output_path, csv_name), index_label=\"ds\")\n\n    with open(os.path.join(output_path, txt_name), \"w\") as f:\n        f.write(normalized_forecast.text)\n\n    return f\"Forecast saved successfully to {output_path}\"\n"
  },
  {
    "name": "create_prediction_agent_and_get_predictions",
    "description": "\nThis tool creates a BinaryPredictor agent with your session and input data model and then provides prediction input \ndata to the agent and returns the consensus a prediction from a panel of experts along with their individual estimates\nand text explanations. The agent also returns the alpha and beta parameters for a Beta distribution that allows you to\nestimate the confidence interval of its consensus probability estimate.\n\nWhen to use this tool:\n- Use this tool to request a probability estimate from Chronulus in situation when there is a binary outcome\n- This tool is specifically made to estimate the probability of an event occurring and not occurring and does not \nrequire historical data\n\nHow to use this tool:\n- First, make sure you have a session_id for the prediction use case.\n- Next, think about the features / characteristics most suitable for producing the requested prediction and then \ncreate an input_data_model that corresponds to the input_data you will provide for the thing or event being predicted.\n- Remember to pass all relevant information to Chronulus including text and images provided by the user. \n- If a user gives you files about a thing you are forecasting or predicting, you should pass these as inputs to the \nagent using one of the following types: \n    - ImageFromFile\n    - List[ImageFromFile]\n    - TextFromFile\n    - List[TextFromFile]\n    - PdfFromFile\n    - List[PdfFromFile]\n- If you have a large amount of text (over 500 words) to pass to the agent, you should use the Text or List[Text] field types\n- Finally, provide the number of experts to consult. The minimum and default number is 2, but users may request up to 30\n30 opinions in situations where reproducibility and risk sensitively is of the utmost importance. In most cases, 2 to 5 \nexperts is sufficient. \n",
    "input_schema": {
      "$defs": {
        "InputField": {
          "properties": {
            "name": {
              "description": "Field name. Should be a valid python variable name.",
              "title": "Name",
              "type": "string"
            },
            "description": {
              "description": "A description of the value you will pass in the field.",
              "title": "Description",
              "type": "string"
            },
            "type": {
              "default": "str",
              "description": "The type of the field. \n        ImageFromFile takes a single named-argument, 'file_path' as input which should be absolute path to the image to be included. So you should provide this input as json, eg. {'file_path': '/path/to/image'}.\n        ",
              "enum": [
                "str",
                "Text",
                "List[Text]",
                "TextFromFile",
                "List[TextFromFile]",
                "PdfFromFile",
                "List[PdfFromFile]",
                "ImageFromFile",
                "List[ImageFromFile]"
              ],
              "title": "Type",
              "type": "string"
            }
          },
          "required": [
            "name",
            "description"
          ],
          "title": "InputField",
          "type": "object"
        }
      },
      "properties": {
        "session_id": {
          "description": "The session_id for the forecasting or prediction use case",
          "title": "Session Id",
          "type": "string"
        },
        "input_data_model": {
          "description": "Metadata on the fields you will include in the input_data.",
          "items": {
            "$ref": "#/$defs/InputField"
          },
          "title": "Input Data Model",
          "type": "array"
        },
        "input_data": {
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "items": {
                  "additionalProperties": true,
                  "type": "object"
                },
                "type": "array"
              }
            ]
          },
          "description": "The forecast inputs that you will pass to the chronulus agent to make the prediction. The keys of the dict should correspond to the InputField name you provided in input_fields.",
          "title": "Input Data",
          "type": "object"
        },
        "num_experts": {
          "description": "The number of experts to consult when forming consensus",
          "title": "Num Experts",
          "type": "integer"
        }
      },
      "required": [
        "session_id",
        "input_data_model",
        "input_data",
        "num_experts"
      ],
      "title": "create_prediction_agent_and_get_predictionsArguments",
      "type": "object"
    },
    "annotations": {},
    "implementation": "# file: /Users/xue/workspace/mcp_project/mcp_server_pyrepos/chronulus-mcp/src/chronulus_mcp/agent/predictor.py\n# module: src.chronulus_mcp.agent.predictor\n# qname: src.chronulus_mcp.agent.predictor.create_prediction_agent_and_get_predictions\n# lines: 13-92\nasync def create_prediction_agent_and_get_predictions(\n        session_id: Annotated[str, Field(description=\"The session_id for the forecasting or prediction use case\")],\n        input_data_model: Annotated[List[InputField], Field(\n            description=\"\"\"Metadata on the fields you will include in the input_data.\"\"\"\n        )],\n        input_data: Annotated[Dict[str, Union[str, dict, List[dict]]], Field(description=\"The forecast inputs that you will pass to the chronulus agent to make the prediction. The keys of the dict should correspond to the InputField name you provided in input_fields.\")],\n        ctx: Context,\n        num_experts: Annotated[int, Field(description=\"The number of experts to consult when forming consensus\")],\n) -> Union[str, Dict[str, Union[dict, str]]]:\n    \"\"\"Queues and retrieves a binary event prediction from Chronulus with a predefined session_id\n\n    This tool creates a BinaryPredictor agent and then provides a prediction input to the agent and returns the prediction data and\n    text explanations from each of the experts consulted by the agent.\n\n    Args:\n        session_id (str): The session_id for the forecasting or prediction use case.\n        input_data_model (List[InputField]): Metadata on the fields you will include in the input_data. Eg., for a field named \"brand\", add a description like \"the brand of the product to forecast\"\n        input_data (Dict[str, Union[str, dict, List[dict]]]): The prediction inputs that you will pass to the chronulus agent to make the prediction. The keys of the dict should correspond to the InputField name you provided in input_fields.\n        ctx (Context): Context object providing access to MCP capabilities.\n        num_experts (int): The number of experts to consult when forming consensus.\n\n    Returns:\n        Union[str, Dict[str, Union[dict, str]]]: a dictionary with prediction data, a text explanation of the predictions, agent_id, and probability estimate.\n    \"\"\"\n\n\n    try:\n        chronulus_session = Session.load_from_saved_session(session_id=session_id, verbose=False)\n    except Exception as e:\n        error_message = f\"Failed to retrieve session with session_id: {session_id}\\n\\n{e}\"\n        _ = await ctx.error( message=error_message)\n        return error_message\n\n    try:\n        InputItem = generate_model_from_fields(\"InputItem\", input_data_model)\n    except Exception as e:\n        error_message = f\"Failed to create InputItem model with input data model: {json.dumps(input_data_model, indent=2)}\\n\\n{e}\"\n        _ = await ctx.error(message=error_message)\n        return error_message\n\n    try:\n        item = InputItem(**input_data)\n    except Exception as e:\n        error_message = f\"Failed to validate the input_data with the generated InputItem model. \\n\\n{e}\"\n        _ = await ctx.error(message=error_message)\n        return error_message\n\n    try:\n        agent = BinaryPredictor(\n            session=chronulus_session,\n            input_type=InputItem,\n            verbose=False,\n        )\n    except Exception as e:\n        return f\"\"\"Error at nf_agent: {str(e)}\n        \ninput_fields = {input_data_model}\n\ninput_data = {json.dumps(input_data, indent=2)}\n\ninput_type = {str(type(InputItem))}\n\"\"\"\n\n    try:\n\n        req = agent.queue(item, num_experts=num_experts, note_length=(5,10))\n    except Exception as e:\n        return f\"\"\"Error at nf_agent: {str(e)}\"\"\"\n\n    try:\n        prediction_set = agent.get_request_predictions(req.request_id)\n        return {\n            \"agent_id\": agent.estimator_id,\n            \"request_id\": req.request_id,\n            \"beta_params\": prediction_set.beta_params,\n            'expert_opinions': [p.text for p in prediction_set],\n            'probability': prediction_set.prob_a}\n\n    except Exception as e:\n        return f\"\"\"Error on prediction: {str(e)}\"\"\"\n\n#callee：\n# file: /Users/xue/workspace/mcp_project/mcp_server_pyrepos/chronulus-mcp/src/chronulus_mcp/agent/_types.py\n# module: src.chronulus_mcp.agent._types\n# qname: src.chronulus_mcp.agent._types.generate_model_from_fields\n# lines: 26-65\ndef generate_model_from_fields(model_name: str, fields: List[InputField]) -> Type[BaseModel]:\n    \"\"\"\n    Generate a new Pydantic BaseModel from a list of InputField objects.\n\n    Args:\n        model_name: The name for the generated model class\n        fields: List of InputField objects defining the model's fields\n\n    Returns:\n        A new Pydantic BaseModel class with the specified fields\n    \"\"\"\n    literal_type_mapping = {\n        'str': str,\n        'ImageFromFile': ImageFromFile,\n        'List[ImageFromFile]': List[ImageFromFile],\n        'TextFromFile': TextFromFile,\n        'List[TextFromFile]': List[TextFromFile],\n        'PdfFromFile': PdfFromFile,\n        'List[PdfFromFile]': List[PdfFromFile]\n    }\n\n    field_definitions = {\n        field.name: (\n            Optional[literal_type_mapping.get(field.type, str)],\n            Field(description=field.description)\n        )\n        for field in fields\n    }\n\n    DynamicModel = create_model(\n        model_name,\n        __base__=BaseModel,  # Explicitly set BaseModel as the base class\n        **field_definitions\n    )\n\n    DynamicModel.__annotations__ = {\n        field.name: str for field in fields\n    }\n\n    return DynamicModel\n"
  },
  {
    "name": "reuse_prediction_agent_and_get_prediction",
    "description": "\nThis tool provides prediction input data to a previously created Chronulus BinaryPredictor agent and returns the \nconsensus a prediction from a panel of experts along with their individual estimates and text explanations. The agent \nalso returns the alpha and beta parameters for a Beta distribution that allows you to estimate the confidence interval \nof its consensus probability estimate.\n\nWhen to use this tool:\n- Use this tool to request a prediction from a Chronulus prediction agent that you have already created and when your \ninput data model is unchanged\n- Use this tool to request a probability estimate from an existing prediction agent in a situation when there is a binary outcome\n- This tool is specifically made to estimate the probability of an event occurring and not occurring and does not \nrequire historical data\n\nHow to use this tool:\n- First, make sure you have a session_id for the prediction use case.\n- Next, think about the features / characteristics most suitable for producing the requested prediction and then \ncreate an input_data_model that corresponds to the input_data you will provide for the thing or event being predicted.\n- Remember to pass all relevant information to Chronulus including text and images provided by the user. \n- If a user gives you files about a thing you are forecasting or predicting, you should pass these as inputs to the \nagent using one of the following types: \n    - ImageFromFile\n    - List[ImageFromFile]\n    - TextFromFile\n    - List[TextFromFile]\n    - PdfFromFile\n    - List[PdfFromFile]\n- If you have a large amount of text (over 500 words) to pass to the agent, you should use the Text or List[Text] field types\n- Finally, provide the number of experts to consult. The minimum and default number is 2, but users may request up to 30\n30 opinions in situations where reproducibility and risk sensitively is of the utmost importance. In most cases, 2 to 5 \nexperts is sufficient. \n\nHow to use this tool:\n- First, make sure you have an agent_id for the prediction agent. The agent is already attached to the correct session. \nSo you do not need to provide a session_id.\n- Next, reference the input data model that you previously used with the agent and create new input data for the item \nbeing predicted that aligns with the previously specified input data model\n- Remember to pass all relevant information to Chronulus including text and images provided by the user. \n- If a user gives you files about a thing you are forecasting or predicting, you should pass these as inputs to the \nagent using one of the following types: \n    - ImageFromFile\n    - List[ImageFromFile]\n    - TextFromFile\n    - List[TextFromFile]\n    - PdfFromFile\n    - List[PdfFromFile]\n- If you have a large amount of text (over 500 words) to pass to the agent, you should use the Text or List[Text] field types\n- Finally, provide the number of experts to consult. The minimum and default number is 2, but users may request up to 30\n30 opinions in situations where reproducibility and risk sensitively is of the utmost importance. In most cases, 2 to 5 \nexperts is sufficient. \n",
    "input_schema": {
      "properties": {
        "agent_id": {
          "description": "The agent_id for the forecasting or prediction use case and previously defined input_data_model",
          "title": "Agent Id",
          "type": "string"
        },
        "input_data": {
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "items": {
                  "additionalProperties": true,
                  "type": "object"
                },
                "type": "array"
              }
            ]
          },
          "description": "The forecast inputs that you will pass to the chronulus agent to make the prediction. The keys of the dict should correspond to the InputField name you provided in input_fields.",
          "title": "Input Data",
          "type": "object"
        },
        "num_experts": {
          "description": "The number of experts to consult when forming consensus",
          "title": "Num Experts",
          "type": "integer"
        }
      },
      "required": [
        "agent_id",
        "input_data",
        "num_experts"
      ],
      "title": "reuse_prediction_agent_and_get_predictionArguments",
      "type": "object"
    },
    "annotations": {},
    "implementation": "# file: /Users/xue/workspace/mcp_project/mcp_server_pyrepos/chronulus-mcp/src/chronulus_mcp/agent/predictor.py\n# module: src.chronulus_mcp.agent.predictor\n# qname: src.chronulus_mcp.agent.predictor.reuse_prediction_agent_and_get_prediction\n# lines: 95-134\nasync def reuse_prediction_agent_and_get_prediction(\n        agent_id: Annotated[str, Field(description=\"The agent_id for the forecasting or prediction use case and previously defined input_data_model\")],\n        input_data: Annotated[Dict[str, Union[str, dict, List[dict]]], Field(\n            description=\"The forecast inputs that you will pass to the chronulus agent to make the prediction. The keys of the dict should correspond to the InputField name you provided in input_fields.\")],\n        num_experts: Annotated[int, Field(description=\"The number of experts to consult when forming consensus\")],\n\n) -> Union[str, Dict[str, Union[dict, str]]]:\n    \"\"\"Queues and retrieves a binary event prediction from Chronulus with a previously created agent_id\n\n    This tool provides a prediction input to a previous created Chronulus BinaryPredictor agent and returns the\n    prediction data and text explanations from each of the experts consulted by the agent.\n\n    Args:\n        agent_id (str): The agent_id for the forecasting or prediction use case and previously defined input_data_model\n        input_data (Dict[str, Union[str, dict, List[dict]]]): The forecast inputs that you will pass to the chronulus agent to make the prediction. The keys of the dict should correspond to the InputField name you provided in input_fields.\n        num_experts (int): The number of experts to consult when forming consensus.\n\n    Returns:\n        Union[str, Dict[str, Union[dict, str]]]: a dictionary with prediction data, a text explanation of the predictions, agent_id, and probability estimate.\n    \"\"\"\n\n    agent = BinaryPredictor.load_from_saved_estimator(estimator_id=agent_id, verbose=False)\n    item = agent.input_type(**input_data)\n\n    try:\n        req = agent.queue(item, num_experts=num_experts, note_length=(5,10))\n    except Exception as e:\n        return f\"\"\"Error at nf_agent: {str(e)}\"\"\"\n\n    try:\n        prediction_set = agent.get_request_predictions(req.request_id)\n        return {\n            \"agent_id\": agent.estimator_id,\n            \"request_id\": req.request_id,\n            \"beta_params\": prediction_set.beta_params,\n            'expert_opinions': [p.text for p in prediction_set],\n            'probability': prediction_set.prob_a}\n\n    except Exception as e:\n        return f\"\"\"Error on prediction: {str(e)}\"\"\"\n"
  },
  {
    "name": "save_prediction_analysis_html",
    "description": "\nA tool that saves an analysis of a BinaryPredictor prediction to HTML. \n\nThe analysis includes a plot of the theoretical and empirical beta distribution estimated by Chronulus and also\nlist the opinions provided by each expert.\n\nWhen to use this tool:\n- Use this tool when you need to save the BinaryPredictor estimates to for the user\n\nHow to use this tool:\n- Provide the request_id from a previous prediction response\n- Specify the output_path where the html should be saved\n- Provide html_name for the file (must end in .html)\n- The tool will provide status updates through the MCP context\n",
    "input_schema": {
      "properties": {
        "request_id": {
          "description": "The request_id from the BinaryPredictor result",
          "title": "Request Id",
          "type": "string"
        },
        "output_path": {
          "description": "The path where the HTML file should be saved.",
          "title": "Output Path",
          "type": "string"
        },
        "html_name": {
          "description": "The path where the HTML file should be saved.",
          "title": "Html Name",
          "type": "string"
        },
        "title": {
          "description": "Title of analysis",
          "title": "Title",
          "type": "string"
        },
        "plot_label": {
          "description": "Label for the Beta plot",
          "title": "Plot Label",
          "type": "string"
        },
        "chronulus_prediction_summary": {
          "description": "A summary paragraph distilling prediction results and expert opinions provided by Chronulus",
          "title": "Chronulus Prediction Summary",
          "type": "string"
        },
        "dist_shape": {
          "description": "A one line description of the shape of the distribution of predictions",
          "title": "Dist Shape",
          "type": "string"
        },
        "dist_shape_interpretation": {
          "description": "2-3 sentences interpreting the shape of the distribution of predictions in layman's terms",
          "title": "Dist Shape Interpretation",
          "type": "string"
        }
      },
      "required": [
        "request_id",
        "output_path",
        "html_name",
        "title",
        "plot_label",
        "chronulus_prediction_summary",
        "dist_shape",
        "dist_shape_interpretation"
      ],
      "title": "save_prediction_analysis_htmlArguments",
      "type": "object"
    },
    "annotations": {},
    "implementation": "# file: /Users/xue/workspace/mcp_project/mcp_server_pyrepos/chronulus-mcp/src/chronulus_mcp/io.py\n# module: src.chronulus_mcp.io\n# qname: src.chronulus_mcp.io.save_prediction_analysis_html\n# lines: 65-148\nasync def save_prediction_analysis_html(\n    request_id: Annotated[str, Field(description=\"The request_id from the BinaryPredictor result\")],\n    output_path: Annotated[str, Field(description=\"The path where the HTML file should be saved.\")],\n    html_name: Annotated[str, Field(description=\"The path where the HTML file should be saved.\")],\n    title: Annotated[str, Field(description=\"Title of analysis\")],\n    plot_label: Annotated[str, Field(description=\"Label for the Beta plot\")],\n    chronulus_prediction_summary: Annotated[str, Field(description=\"A summary paragraph distilling prediction results and expert opinions provided by Chronulus\")],\n    dist_shape: Annotated[str, Field(description=\"A one line description of the shape of the distribution of predictions\")],\n    dist_shape_interpretation: Annotated[str, Field(description=\"2-3 sentences interpreting the shape of the distribution of predictions in layman's terms\")],\n    #ctx: Context,\n) -> str:\n    \"\"\"Saves the analysis from a BinaryPredictor prediction to an HTML file\n\n    Args:\n        request_id (str): The request_id from the BinaryPredictor result\n        output_path (str): The path where the CSV and TXT file should be saved.\n        html_name (str): The name of the HTML file to be saved. Should end in .html\n        title (str): Title of analysis\n        plot_label (str): Label for the Beta plot\n        chronulus_prediction_summary (str) : A summary paragraph distilling prediction results and expert opinions provided by Chronulus\n        dist_shape (str) : A one line description of the shape of the distribution of predictions\n        dist_shape_interpretation (str) : A 2-3 sentences interpreting the shape of the distribution of predictions in layman's terms\n\n    Returns:\n        str: A message confirming the file was saved and its location\n    \"\"\"\n    # Get normalized forecast and rescale it\n    #_ = await ctx.info(f\"Fetching prediction data for request_id: {request_id}\")\n\n    html = get_html_template(\"binary_predictor_analysis.html\")\n\n    prediction_set = BinaryPredictor.get_request_predictions_static(request_id, verbose=False)\n\n    mean = prediction_set.prob_a\n    a, b = prediction_set.beta_params.alpha, prediction_set.beta_params.beta\n    variance = (a*b) / (((a+b)**2)*(a+b+1))\n    stdev = math.sqrt(variance)\n    divergent = a <= 1 or b <= 1\n    mode = (a - 1) / (a + b - 2)\n    mode_txt = f\"{mode: 16.4f}\" if not divergent else 'Diverges'\n\n    html = html.replace(\"[TITLE_OF_ANALYSIS]\", title)\n    html = html.replace(\"[PLOT_LABEL]\", plot_label)\n    html = html.replace(\"[CHRONULUS_PREDICTION_SUMMARY]\", chronulus_prediction_summary)\n    html = html.replace(\"[DIST_SHAPE_DESCRIPTION]\", dist_shape)\n    html = html.replace(\"[DIST_SHAPE_INTERPRETATION]\", dist_shape_interpretation)\n    html = html.replace(\"[ALPHA]\", f\"{a: 16.16f}\")\n    html = html.replace(\"[BETA]\", f\"{b: 16.16f}\")\n    html = html.replace(\"[MEAN]\", f\"{mean: 16.4f}\")\n    html = html.replace(\"[VARIANCE]\", f\"{variance: 16.4f}\")\n    html = html.replace(\"[STDEV]\", f\"{stdev: 16.4f}\")\n    html = html.replace(\"[MODE]\", mode_txt)\n\n    date = datetime.today().strftime(\"%B %d, %Y\")\n    html = html.replace(\"[DATE]\", date)\n\n    expert_opinion_list = []\n    for i, p in enumerate(prediction_set):\n        pos_text = p.opinion_set.positive.text\n        neg_text = p.opinion_set.negative.text\n        pos = f\"\"\"\n        <div class=\"expert-opinion positive-case\">\n            <h3>Expert {i+1} - Positive Case</h3>\n                <pre>{pos_text}</pre>\n        </div>\n        \"\"\"\n        neg = f\"\"\"\n        <div class=\"expert-opinion negative-case\">\n            <h3>Expert {i+1} - Negative Case</h3>\n                <pre>{neg_text}</pre>\n        </div>\n        \"\"\"\n        expert_opinion_list.append(pos)\n        expert_opinion_list.append(neg)\n\n    expert_opinions = \"\\n\\n\".join(expert_opinion_list)\n\n    html = html.replace(\"[EXPERT_OPINIONS]\", expert_opinions)\n\n\n    with open(os.path.join(output_path, html_name), \"w\") as f:\n        f.write(html)\n\n    return f\"BinaryPredictor analysis saved successfully to {output_path}\"\n\n#callee：\n# file: /Users/xue/workspace/mcp_project/mcp_server_pyrepos/chronulus-mcp/src/chronulus_mcp/assets.py\n# module: src.chronulus_mcp.assets\n# qname: src.chronulus_mcp.assets.get_html_template\n# lines: 26-41\ndef get_html_template(filename: str) -> str:\n    \"\"\"\n    Get the code for a html template.\n\n    Returns\n    -------\n    str\n        Html template source code\n    \"\"\"\n    # Get the package directory\n    for file in resources.files(\"chronulus_mcp._assets.html\").iterdir():\n        if file.is_file() and file.name == filename:\n            contents = file.read_text()\n            return contents\n\n    raise FileNotFoundError(filename)\n"
  },
  {
    "name": "get_risk_assessment_scorecard",
    "description": "\nA tool that retrieves the risk assessment scorecard for the Chronulus Session in Markdown format\n\nWhen to use this tool:\n- Use this tool when the use asks about the risk level or safety concerns of a forecasting use case\n- You may also use this tool to provide justification to a user if you would like to warn them of the implications of \n    what they are asking you to forecasting or predict.\n\nHow to use this tool:\n- Make sure you have a session_id for the forecasting or prediction use case\n- When displaying the scorecard markdown for the user, you should use an MDX-style React component\n",
    "input_schema": {
      "properties": {
        "session_id": {
          "description": "The session_id for the forecasting or prediction use case",
          "title": "Session Id",
          "type": "string"
        },
        "as_json": {
          "description": "If true, returns the scorecard in JSON format, otherwise returns a markdown formatted scorecard",
          "title": "As Json",
          "type": "boolean"
        }
      },
      "required": [
        "session_id",
        "as_json"
      ],
      "title": "get_risk_assessment_scorecardArguments",
      "type": "object"
    },
    "annotations": {},
    "implementation": "# file: /Users/xue/workspace/mcp_project/mcp_server_pyrepos/chronulus-mcp/src/chronulus_mcp/session.py\n# module: src.chronulus_mcp.session\n# qname: src.chronulus_mcp.session.get_risk_assessment_scorecard\n# lines: 45-65\nasync def get_risk_assessment_scorecard(\n        session_id: Annotated[str, Field(description=\"The session_id for the forecasting or prediction use case\")],\n        as_json:  Annotated[bool, Field(description=\"If true, returns the scorecard in JSON format, otherwise returns a markdown formatted scorecard\")]\n) -> str:\n    \"\"\"Get the risk assessment scorecard for the Session\n\n    Args:\n        session_id (str): The session_id for the forecasting or prediction use case.\n        as_json (bool): If true, returns the scorecard in JSON format, otherwise returns a markdown formatted scorecard\n\n    Returns:\n        str: a risk assessment scorecard in the specified format.\n    \"\"\"\n\n    chronulus_session = Session.load_from_saved_session(session_id=session_id, verbose=False)\n    scorecard_md = chronulus_session.risk_scorecard(width='100%')\n    if as_json:\n        content = json.dumps(chronulus_session.scorecard.model_dump())\n    else:\n        content = scorecard_md\n    return content\n"
  }
]